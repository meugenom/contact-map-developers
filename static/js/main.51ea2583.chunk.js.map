{"version":3,"sources":["components/Services/StreamStore.js","components/Services/Grammar.js","components/Services/Parser/Google.js","components/SearchControl/SearchControlList.js","components/SearchControl/SearchControl.js","components/Utils/Utilits.js","components/Services/Config.js","components/Services/Service.js","components/Services/Models/Token.js","components/Services/Parser/Lexer.js","components/Services/Parser/Parser.js","components/Services/PersonStore.js","components/ContactMap/Contactmap.js","components/App/App.js","index.js"],"names":["instance","StreamStore","this","_data","stream","push","Object","freeze","Grammar","tokens","patterns","Google","word","list","streamStore","get","result","grammar","length","undefined","toLowerCase","slice","replace","trim","splitedWords","splitWord","replaceUncorrectedWords","map","token","keyWord","splitedWord","isNaN","getValue","value","type","getType","match","matchBySearchedWords","inputArray","inputObject","key","uniq","resultObject","count","b","tokenB","getId","console","log","a","sort","filter","item","pos","ary","split","pattern","keyPatern","array","findMatches","forEach","SearchControlList","props","clickListItem","event","searchedList","li","document","querySelectorAll","liSection","updateList","i","getAttribute","remove","state","keys","activelist","google","showList","search","setState","find","sectionList","getElementsByClassName","firstChild","removeChild","createElement","className","setAttribute","innerHTML","getFeature","properties","username","city","about","addEventListener","e","target","matches","appendChild","Component","SearchControl","pressKeyInput","isCloseButtonVisible","isWrapperList","keyCode","inputValue","updateInfo","newPersons","features","isSearchVisible","clickOpenSearchButton","bind","clickCloseButton","closeSearch","onClick","viewBox","x1","y1","x2","y2","cx","cy","r","fill","placeholder","onKeyDown","onChange","d","Utils","element","func","attachEvent","Config","host","dataType","Service","CONFIG","data","getCall","options","method","headers","fetch","response","json","Token","id","position","start","line","column","end","feature","Lexer","createToken","checkTokens","str","setType","setValue","setPositionStartLine","setPositionStartColumn","String","setPositionEndLine","setPositionEndColumn","setId","setFeature","Parser","sortedStream","mapped","el","index","PersonStore","persons","ContactMap","boundariesColor","color","center","latLngGeom","boundaries","geometry","group","mapRef","useRef","onLoading","getData","then","personStore","set","getStream","prepare","error","loadDefault","examplePersons","useEffect","osm","L","TileLayer","boundaryCanvas","boundary","attribution","current","zoom","layers","minZoom","maxZoom","zoomSnap","activeIcon","icon","iconUrl","iconSize","iconAnchor","inactiveIcon","boundariesLayer","geoJSON","style","clusters","markerClusterGroup","spiderfyOnMaxZoom","showCoverageOnHover","zoomToBoundsOnClick","chunkedLoading","ActivePeoples","geoJson","pointToLayer","latlng","marker","removeLayer","bindPopup","name","Subscribe","openPopup","addLayer","flyTo","coordinates","markersGroup","featureGroup","fitBounds","getBounds","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.51ea2583.chunk.js","sourcesContent":["/**\n *  this Store save token's stream for next using by search\n */\n\nclass StreamStore {\n  constructor() {\n    if (!StreamStore.instance) {\n      this._data = [];\n      StreamStore.instance = this;\n    }\n\n    return StreamStore.instance;\n  }\n\n  get() {\n    return this._data[0];\n  }\n\n  set(stream) {\n    this._data.push(stream)\n  }\n\n\n}\n\nconst instance = new StreamStore();\nObject.freeze(instance);\n\nexport default instance;","/**\n    Grammar is descriptions about tokens\n    @return patterns for search tokens and making tokens stream\n */\n\nconst Grammar = {    \n            tokens : {                \n                patterns: {\n                    \"javascript\": /[j|J](ava|)[s|S](cript|)/g,\n                    //\"java\" : /[j|J](ava|AVA)(\\s)/g,\n                    \"java\" : /[j|J][a|A][v|V][a|A](\\s|$)/g,\n                    \"c++\" : /[c|C](\\++|\\+|plus)/g,\n                    \"python\" : /[p|P](i|y|I|Y)(ton|thon|TON|THON)/g,\n                    \"php\" : /[p|P](h|H)(P|p)/g,\n                    \"swift\" : /[s|S](wift|WIFT)/g,\n                    \"android\" : /[a|A](ndroid|droid|NDROID|ndroid|nroid|NROID)/g,\n                    \"ios\" : /[i|I](OS|os|0s)/g,\n                    \"bash\" : /[b|B](ash|ASH)/g,\n                    \"text@en\" : /[a-zäöüA-ZÄÖÜ0-9_\\-\\+\\.\\:\\,\\!]+[\\w\\-\\+\\.\\:\\,\\!]/g,\n                    \"text@ru\" :/[аАбБвВгГдДеЕёЁжЖзЗиИйЙкКлЛмМнНоОпПрРсСтТуУфФхХцЦчЧшШщЩъЪыЫьЬэЭюЮяЯ]+/g               \n                }\n            }   \n        }\n\nexport default Grammar;","import streamStore from '../StreamStore';\nimport grammar from '../Grammar';\n\nexport default class Google {\n\n    /**\n     * \n     * @param {searched value from input search, typed in the browser} word \n     * @returns {array of tokens, which have token.value like @param:word}\n     */\n\n    find(word) {\n\n        var list = streamStore.get();\n        var result = []\n        var patterns = grammar.tokens.patterns;\n\n        if (word != null && word.length >= 1 && word != undefined) {\n\n            word = word.toLowerCase();\n            //slice word if > 20 symbols\n            word = word.slice(0, 20);\n\n            //replace html entities from  the string            \n            word = word.replace(/([&<>\\\"'@#*+\\(\\)])/g, \"\");\n\n            //delete backspaces in the start and end of the word\n            word = word.trim();\n\n            //if in the search input we have more searched words\n            var splitedWords = this.splitWord(word);\n            splitedWords = this.replaceUncorrectedWords(splitedWords, patterns)                \n\n            list.map(token => {\n\n                for (var keyWord in splitedWords) {\n\n                    var splitedWord = splitedWords[keyWord];\n\n\n                //number returns already undefined\n                // it will be checked as string or number\n                if (isNaN(token.getValue())) {\n\n                    var value = token.getValue();\n                    var type = token.getType();       \n                \n                    if ((value.toLowerCase()).match(splitedWord) || type == splitedWord) {\n                        \n                        result.push(token);\n\n                    }\n\n                } else {\n                \n                    if ((token.getValue()).match(splitedWord)) {\n                        \n                        result.push(token);\n\n                    }\n                }\n            }\n            \n        })\n\n            return this.matchBySearchedWords(result, splitedWords)\n            \n            //remove double values and return \n            //return this.uniq(result);\n            \n        }\n        //if result []\n        return result;\n    }\n\n    /**\n     * \n     * @param {*} inputArray \n     * @param {*} splitedWords \n     */\n\n    matchBySearchedWords(inputArray, splitedWords) {\n\n        var inputObject = {};\n        for (var keyWord in splitedWords) {\n            inputObject[splitedWords[keyWord]] = []\n        }\n        inputObject[\"text@en\"] = []\n        inputObject[\"text@ru\"] = []\n\n        inputArray.map(token => {\n            for (var key in inputObject) {\n                if (token.getType() == key && key != 'text@en' && key != 'text@ru') {\n                    (inputObject[key]).push(token)\n                }\n                if (token.getValue().toLowerCase().match(key)) {\n                    (inputObject[key]).push(token)\n                }\n            }\n        })\n\n\n        for (var key in inputObject) {\n            inputObject[key] = this.uniq(inputObject[key])\n        }\n\n\n        var resultObject = {}\n        var count = 0;\n        for (var key in inputObject) {\n            if (count > 0 && inputObject[key].length > 0) {\n                var b = inputObject[key]\n                resultObject[count] = [];\n                // eslint-disable-next-line no-loop-func\n                b.map(tokenB => {\n                    resultObject[count - 1].map(token => {\n                        if (token.getId() == tokenB.getId()) {\n                            resultObject[count].push(token);\n                        }\n                    })\n                })\n                count++;\n            }\n            if (count == 0) {\n                resultObject[count] = inputObject[key];\n                count++;\n            }\n        }\n        console.log(splitedWords)\n        //console.log(result)\n        //console.log('count: '+count)\n        //console.log(inputObject)\n        //console.log(resultObject[count-1])\n        return resultObject[count - 1]\n    }\n\n\n    /**\n     * @param {array with doubled tokens} a\n     * @returns {array without unidue values}  \n     */\n    uniq(a) {\n        return a.sort(function (a, b) {\n            if (a.getId() > b.getId()) {\n                return 1;\n            }\n            if (a.getId() < b.getId()) {\n                return -1;\n            }\n            return 0;\n        }).filter(function (item, pos, ary) {\n            return !pos || item.getId() != ary[pos - 1].getId();\n        });\n    }\n\n    splitWord(word) {\n        return word.split(' ');\n    }\n\n    findMatches(word, pattern) {\n        return word.match(pattern)\n    }\n\n    /**\n     * \n     * @param {*} splitedWords is array with splited words from search input\n     * @param {*} patterns is regex expressions from Grammar.js\n     * @return corrected array if we have errors in the search input\n     * for example in search input 'pithon java js'\n     * this function returns ['python','java','javascript']\n     */\n    replaceUncorrectedWords(splitedWords, patterns) {\n        //need to correct words if we type js or angularjs or javascript ... it's all about javascript\n        for (var keyWord in splitedWords) {\n            for (var keyPatern in patterns) {\n                const array = this.findMatches(splitedWords[keyWord], patterns[keyPatern]);\n                if (array != null) {\n                    array.forEach(value => {\n                        if (keyPatern != 'text@en' && keyPatern != 'text@ru' && value != undefined && value != null) {\n                            splitedWords[keyWord] = keyPatern;\n                            //console.log('real-word: '+splitedWords[keyWord]+'  pattern-word: '+keyPatern +' value: '+value);           \n                        }\n                    })\n                }\n            }\n        }\n\n        return splitedWords;\n    }\n}","import React, { Component }  from 'react';\nimport Google from '../Services/Parser/Google'\n\n\nexport default class SearchControlList extends Component {\n    \n    \n    constructor(props) {\n        super(props);     \n        this.state = {\n            keys: \"\",\n            activelist: \"closed\"\n        };\n        \n        this.google = new Google();        \n        \n        this.searchedList = []\n\n    }\n\n\n    componentDidUpdate(){\n        if(this.state.activelist != this.props.activelist){\n            this.showList();\n        }\n        \n        this.search(this.props.keys);\n        \n    }\n\n    showList(){\n        this.setState({\n            activelist: this.props.activelist\n          });          \n    }\n\n    clickListItem = ( props, token ) => ( event ) => {    \n\t\t\n\t\tconsole.log(\"choosed\");\n        var searchedList = [];\n        const li = document.querySelectorAll('li[choosed]');\n        const liSection = document.querySelectorAll('li[key]');\n        if(li[0]){            \n            searchedList.push(token);\n            props.updateList(searchedList);\n            \n            for(var i=0; i < liSection.length; i++){\n                if(liSection[i].getAttribute('choosed')==null){\n                    liSection[i].remove();\n                }\n            }\n\n        }\n    }\n\n    search(word){        \n        this.searchedList = this.google.find(word)\n        \n        //console.log(this.searchedList)\n        \n        //if(this.searchedList[0]){\n            \n            //send list to props of the parent component \n            this.props.updateList(this.searchedList);\n\n            const sectionList = document.getElementsByClassName('search-control-info-list');\n            \n            while (sectionList[0].firstChild) {\n                sectionList[0].removeChild(sectionList[0].firstChild);\n              }\n            \n              //console.log(this.searchedList)\n\n              this.searchedList.forEach(token =>{\n                var li = document.createElement('li');\n                li.className = 'search-control-info-list-item'\n                li.setAttribute('key', token.getId())     \n                li.innerHTML= `\n                    <div className = \"left\">\n                        <img src=\"./img/programmer.png\" alt=\"avatar\"/>\n                        <h3>${token.getFeature().properties.username}</h3>\n                        <h3>${token.getFeature().properties.city}</h3>                    \n                    </div>\n                    <div className = \"right\">\n                        <p>About: ${token.getFeature().properties.about}</p>                \n                    </div> `\n\t\t\t\t\n\t\t\t\tli.addEventListener(\"click\", function(e){\n\t\t\t\t\tconsole.log(e);\n                    if (e.target && e.target.matches(\"li.search-control-info-list-item\")) {\n                        e.target.setAttribute(\"choosed\", \"true\"); // new attribute                     \n                      }\n                }, true);\n\n\t\t\t\tli.addEventListener(\"click\", this.clickListItem(this.props, token), true);\n\t\t\t\t\n\n                sectionList[0].appendChild(li);\n            })\n            \n        //}\n    }\n\n\nrender() {\n\n    return (\n        <ul className=\"search-control-info-list\">                         \n        </ul>\n    );\n    }\n}\n","import React, {Component, useState} from 'react';\nimport SearchControlList from './SearchControlList'\nimport './search-control.css'\n\n\nexport default class SearchControl extends Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            isSearchVisible: false,\n            isCloseButtonVisible: false,\n            isWrapperList: \"closed\",\n            inputValue: \"\"\n        };\n\n\n        //bind for callbacks\n        this.clickOpenSearchButton = this.clickOpenSearchButton.bind(this);\n        this.clickCloseButton = this.clickCloseButton.bind(this);\n        this.pressKeyInput = this.pressKeyInput.bind(this); \n        \n    }\n\n    clickOpenSearchButton() {\n        this.setState(state => ({\n            isSearchVisible: !state.isSearchVisible,\n            isWrapperList: \"closed\",\n            inputValue: \"\"        \n        }));\n\n        //send close to high component for update map view\n        this.props.closeSearch('closed');\n        //remove all children from search list\n        const sectionList = document.getElementsByClassName('search-control-info-list');            \n            while (sectionList[0].firstChild) {\n                sectionList[0].removeChild(sectionList[0].firstChild);\n              }\n    }\n\n\n    clickCloseButton() {\n        this.setState(state => ({\n            isCloseButtonVisible: !state.isCloseButtonVisible,\n            isSearchVisible: false,\n            isWrapperList: \"closed\",\n            inputValue: ''\n        }));\n\n        //send close to high component for update map view\n        this.props.closeSearch('closed');\n        \n        //remove all children from search list\n        const sectionList = document.getElementsByClassName('search-control-info-list');            \n            while (sectionList[0].firstChild) {\n                sectionList[0].removeChild(sectionList[0].firstChild);\n              }\n    }\n\n    \n    pressKeyInput = (props, document) =>(e) => {\n        \n        //visible close button \n        this.setState(state => ({\n            isCloseButtonVisible: true,\n            isWrapperList: \"opened\"\n        }));\n                \n        //var nodes = document.getElementsByClassName(\"search-control-info-list-item\");\n\n        if (e.keyCode == 40) { \n            //TODO \n            console.log('key DOWN')\n        } else if (e.keyCode == 38) { \n            //TODO \n            console.log('key UP')\n        } else if (e.keyCode == 13) {\n            //TODO \n            console.log('key ENTER')\n        } else if(e.keyCode == 8) {\n                    \n            console.log('key BACKSPACE')\n            \n            \n            if(this.state.inputValue.length == 0){                \n                \n                //remove all markers\n                props.updateInfo([]);\n                \n                //remove all DOM elements form list\n                const sectionList = document.getElementsByClassName('search-control-info-list');                            \n                while (sectionList[0].firstChild) {\n                    sectionList[0].removeChild(sectionList[0].firstChild);\n                }\n\n\n\n            }            \n            \n        }\n        \n        \n    }\n\n\n    //it's call from SearchControlList to this parent component\n    updateList = (list) => {\n        \n        const newPersons = { \"type\": \"FeatureCollection\", \"features\": [] }  \n        list.forEach(token =>{\n            newPersons.features.push(token.getFeature())\n        })\n        \n                     \n        this.props.updateInfo(newPersons);\n        \n\n    }\n\n    render() {\n      return (\n      <div className=\"search-box\">\n        <article className=\"search-control-wrap\">  \n            <section className={this.state.isSearchVisible?\"search-control search-control-active\":\"search-control\"}>\n                <button className=\"search-control-icon-button\" \n                    onClick={this.clickOpenSearchButton}>                \n                    <svg viewBox=\"0 0 50 50\">\n                        <line x1=\"35\" y1=\"35\" x2=\"46\" y2=\"46\"/>\n                        <circle cx=\"23\" cy=\"23\" r=\"16\" fill=\"none\"></circle> \n                            Sorry, your browser does not support inline SVG.\n                    </svg>                    \n                </button>                \n                <input \n                    type=\"text\" \n                    className=\"search-input search-control-input\" \n                    placeholder=\"custom placeholder\" \n                    onKeyDown={this.pressKeyInput(this.props, document)}\n                    onChange={e => this.setState({ inputValue: e.target.value })} \n                    value={this.state.inputValue}/>                \n                <button className={ this.state.isCloseButtonVisible ? \"search-control-close-button search-control-close-button-active\": \"search-control-close-button\"} onClick={this.clickCloseButton}>\n                    <svg viewBox=\"0 0 50 50\">\n                        <path d=\"M5 5 L45 45 M45 5 L5 45\"/>\n                        Sorry, your browser does not support inline SVG.\n                    </svg>\n                </button>\n            </section>\n            <section className={this.state.isWrapperList==\"opened\"?\"search-control-info-wrapper\":\"search-control-info-wrapper search-control-info-wrapper-close\"} >\n                <section className=\"search-control-info\">            \n                    <SearchControlList \n\n                        activelist={this.state.isWrapperList} \n                        keys={this.state.inputValue}\n                        updateList = {this.updateList}\n                    />\n                </section>            \n            </section>    \n        </article>\n     </div>\n      );\n    }\n  }\n","'use strict'\n\nexport default class Utils {\n\n    constructor () {     \n        this.document = document\n    }\n\n    Subscribe(event, element, func) {\n        if (element.addEventListener) {\n            element.addEventListener(event, func, false);\n        } else if (element.attachEvent) {\n            element.attachEvent(\"on\" + event, func);\n        } else {\n            element['on' + event] = func;\n        }\n      }\n    \n\n}\n\n\n","/**\n * @param host you can use 'http://192.168.0.1/data'\n * @param instance by default data about persons in  file persons.json\n */\n\nconst Config = {\n    \n    /**\n        host: 'api/data', when we use nginx or appache:\n        for route   ^~ / was set localhost:3000 with our started frontend\n        for route ^~ /api/ was set localhost:8081 with our backend server (call for data is '/data')\n        here in the @param host need to write '/api/data'\n     */\n    \n    \n    host: '/api/getData',\n    dataType: 'json'\n}\n\nexport default Config;\n\n\n","'use strict'\n\nimport CONFIG from './Config'\n\n/**\n *\n * @async GET call to the server \n * @param {string: 'json' || 'text'} dataType  \n * @param {string: name of host} host \n * @return {data in format json or text} \n * @return {callback} - for 404 page with Usehistory from React\n */\n\nexport default class Service {\n  \n  constructor(){\n    this.dataType = CONFIG.dataType;\n    this.host = CONFIG.host != '' ? CONFIG.host : null;  \n    this.data = {}; \n  }\n\n  async getData(){\n     return this.getCall();\n  }\n\n  async getCall() {\n        const options = {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json',\n            'Access-Control-Request-Method':'GET'//,\n            //'Access-Control-Request-Headers':'Content-Type, Accept',\n            //'Origin' : 'https://eugenem.dev'\n          }\n        }\n        try {\n          const response = await fetch(this.host, options)\n          const json = await response.json()\n          return json\n\n        } catch (err) {            \n            console.log('Error getting documents', err)\n\n        }\n  }   \n      \n}\n","const Token = class Token {\n\n    constructor() {\n        this.token = {\n            type: \"\",\n            value: \"\",\n            id: \"\",\n            position: {\n                start: {\n                    line: \"\",\n                    column: \"\"\n                },\n                end: {\n                    line: \"\",\n                    column: \"\"\n                }\n            },\n            feature: {}\n        }\n    }\n\n    setType(type) {\n        this.token.type = type;\n    }\n\n    getType() {\n        return this.token.type;\n    }\n\n    setValue(value) {\n        this.token.value = value;\n    }\n\n    getValue() {\n        return this.token.value\n    }\n\n    setId(id) {\n        this.token.id = id;\n    }\n\n    getId() {\n        return this.token.id\n    }\n\n    setPositionStartLine(line) {\n        this.token.position.start.line = line;\n    }\n\n    getPositionStartLine() {\n        return this.token.position.start.line\n    }\n\n    setPositionStartColumn(column) {\n        this.token.position.start.column = column;\n    }\n\n    getPositionStartColumn() {\n        return this.token.position.start.column;\n    }\n\n    setPositionEndLine(line) {\n        this.token.position.end.line = line;\n    }\n\n    getPositionEndLine() {\n        return this.token.position.end.line\n    }\n\n    setPositionEndColumn(column) {\n        this.token.position.end.column = column;\n    }\n\n    getPositionEndColumn() {\n        return this.token.position.end.column;\n    }\n\n    setFeature(feature) {\n        this.token.feature = feature;\n    }\n\n    getFeature() {\n        return this.token.feature;\n    }\n\n}\n\nexport default Token;","import grammar from '../Grammar'\nimport Token from '../Models/Token'\n//import Service from '../Service'\n\n/**\n * Lexer's concept is:\n *   - token stream\n *   - token\n *   - lexical scoping\n *   - lexical context\n *   \n *   @param json file with information about developers\n *   @param Grammar.js with description of tokens      \n *   @return token stream\n *   \n *   @example:\n *       {\n *           type: 'text',\n *           value: 'this is the test',\n *           id: 12,\n *           position : {\n *              start: {\n *                  line: 0,\n *                  column: 1\n *              },\n *              end: {\n *                  line: 0,\n *                  column: 3\n *              }  \n *           },\n *           \"geometry\": {\n *              \"type\": \"Point\",\n *              \"coordinates\": [ \"7.705953\", \"52.358919\"]\n *            }   \n *        }\n *\n */\n\nconst Lexer =  class Lexer {\n\n    constructor(data){        \n        this.stream = [];\n        this.data = data;\n    }\n    \n    getStream(){\n\n            if(this.data !=null && this.data.features){\n            this.data.features.forEach(feature => {                                \n                \n                this.createToken(feature, 'name');\n                this.createToken(feature, 'username');\n                this.createToken(feature, 'city');\n                this.createToken(feature, 'state');\n            \n            /**\n             *  @TODO if we have other options\n                this.createToken(feature, 'company');\n                this.createToken(feature, 'age');        \n             */\n            \n                 //was description \n                this.checkTokens(feature.properties.about, feature);\n            \n            /**\n             * @TODO if we have other options and need to see by regex expression\n             * this.checkTokens(feature.properties.address, feature);        \n             */\n            \n        })  \n        //console.log(this.stream)\n        return this.stream\n        }\n        return [];\n    }\n\n    checkTokens(str, feature){\n\n        var patterns = grammar.tokens.patterns;\n        var line = 0;\n        var column = 0;\n\n\n        for(var key in patterns){      \n            if(str!=null && str!=undefined){\n                str = str.replace(/([&<>\\\"'@#!*\\(\\)])/g,\"\");\n\n                const array = this.findMatches(str, patterns[key]);           \n                if(array!=null){\n                    array.forEach(value => {\n                    \n                        var token = new Token();\n                        token.setType(key);\n                        token.setValue(value);\n                        token.setPositionStartLine(line);\n                        token.setPositionStartColumn(column);\n                        column = String(value).length;\n                        token.setPositionEndLine(line);\n                        token.setPositionEndColumn(column);\n                        token.setId(feature.id);\n                        token.setFeature(feature);\n                        this.stream.push(token);           \n                    }   )\n                }            \n            }            \n        }\n\n    }\n\n    createToken(feature, type){\n        if(feature.properties[type]!=null && feature.properties[type]!=undefined){\n            var line = 0;\n            var column = String(feature.properties[type]).length;\n            var token = new Token();            \n            var value = feature.properties[type];            \n            value = value.replace(/([&<>\\\"'@#!*\\(\\)])/g,\"\");\n\n            token.setType(type);\n            token.setValue(value);\n            token.setPositionStartLine(line);\n            token.setPositionStartColumn(0);            \n            token.setPositionEndLine(line);\n            token.setPositionEndColumn(column);\n            token.setId(feature.id);\n            token.setFeature(feature);                     \n        \n            this.stream.push(token);           \n        }\n    }\n     \n    findMatches(str, pattern){ \n        return str.match(pattern)\n    }\n\n\n}\n\nexport default Lexer;","/**\n *  Syntax Tree is possible, but for first realisaton and quick search we need \n *  to use 'map' and function 'sort()' for abc-sorting \n *\n *  it will be in the future:\n *  Parses a stream of tokens into an Abstract Syntax Tree (AST)\n *  Concept: Absract Syntax Tree (AST), nodes , dynamic scoping, dynamic context\n *  Target: By nodes we can search more quickly and effecient. Nodes we can show as\n *          some filters in our html template\n *  \n *   {\n *      type: 'root',\n *      nodes: [\n *          {\n *          type: 'text',\n *          value: 'abc',\n *          position: {start: {column: 1 line: 1}, end: {column: 3, line: 1}}\n *          },\n *          {\n *          type: 'text',\n *          value: 'fde',\n *          position: {start: {column: 4 line: 1}, end: {column: 8, line: 1}}\n *          }, \n *          ...\n *      ]\n *   }\n * \n * \n */\n\nexport default class Parser {\n    constructor(stream) {\n        this.stream = stream; //new Lexer().getStream();\n        this.sortedStream = [];\n        \n        //prepare stream to quick search\n        //this.prepare();\n    }\n\n    /**\n     * @param {no}\n     * @returns sorted stream for next using by searching of some value\n     * this method isn't actuall if we havn't  hierarchial searching\n     * @TODO need make hierarchial searching by word \n     */\n\n    prepare(){\n        // temp array consists of objects with position and sorting's value\n        var list = this.stream\n        var mapped = list.map(function (el, i) {\n            return {\n                index: i,\n                token: el\n            };\n        });\n\n        //sorting array\n        mapped.sort(function (a, b) {\n            if (a.token.getValue() > b.token.getValue()) {\n                return 1;\n            }\n            if (a.token.getValue() < b.token.getValue()) {\n                return -1;\n            }\n            return 0;\n        });\n\n        //result container\n        var result = mapped.map(function (token) {\n            return list[token.index];\n        });\n        this.sortedStream = result;        \n        return result\n    }\n}","class PersonStore {\n    constructor(){\n     if(! PersonStore.instance){\n       this._data = [];\n       PersonStore.instance = this;\n     }\n  \n     return PersonStore.instance;\n    }\n\n    get(){\n        return this._data[0]; \n    }\n\n    set(persons){\n        this._data.push(persons)\n    }\n\n  \n  }\n  \n  const instance = new PersonStore();\n  Object.freeze(instance);\n  \n  export default instance;","import React, { useEffect, useRef, useState} from 'react';\nimport L from 'leaflet';\nimport 'leaflet.markercluster'\nimport SearchControl from '../SearchControl/SearchControl';\nimport 'leaflet-boundary-canvas';\nimport Utils from '../Utils/Utilits';\nimport boundaries from \"../../data/boundaries.json\";\nimport './ContactMap.css'\n\nimport Service from '../Services/Service'\nimport Lexer from '../Services/Parser/Lexer'\nimport Parser from '../Services/Parser/Parser'\nimport personStore from '../Services/PersonStore'\nimport streamStore from '../Services/StreamStore'\nimport examplePersons from '../../data/demo.json'\n\n\n\nexport default function ContactMap(props) {\n\n  const boundariesColor = { color: \"orange\", fill: false};\n  const center = [51.0, 10.917];\n  const zoom = 6;\n  const minZoom = 4;\n  const maxZoom = 9;\n  const zoomSnap = 0.25\n  const latLngGeom = boundaries.geometry; //Define real geometry here\n  const osmUrl = 'https://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png';\n  const osmAttribution = '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors';\n  var group = [];\n  const mapRef = useRef(null)\n\n\n  /**\n   * loading data from dev server\n   * with error we show clear map in the browser\n   */\n\n  async function onLoading(){\n\n    var action = await new Service().getData().then((persons)=>{      \n      if(persons != undefined && persons.features){\n        personStore.set(persons)      \n        var stream = new Lexer(persons).getStream();     \n        streamStore.set(stream);\n        new Parser(stream).prepare();\n        updateInfo(persons);    \n      }else{\n\n        console.error('Error connection with dev server, we use example data from /data/persons.json')        \n        loadDefault();\n      }     \n    });      \n  }\n\n  function loadDefault(){\n        personStore.set(examplePersons)      \n        var stream = new Lexer(examplePersons).getStream();     \n        streamStore.set(stream);\n        new Parser(stream).prepare();\n        updateInfo(examplePersons);    \n  }\n\n  useEffect(() => {\n\n    var osm = L.TileLayer.boundaryCanvas(osmUrl, {\n      boundary: latLngGeom,\n        attribution: osmAttribution\n    })\n    \n    mapRef.current = L.map('map', {\n        center: center,\n        zoom: zoom,\n        layers: osm,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        zoomSnap: zoomSnap\n    })\n        \n  }, [center, zoom, minZoom, maxZoom, zoomSnap])\n\n  /**\n   *  Set markers and position \n   */\n  \n  //set new icon image for markers\n  const activeIcon = L.icon({\n    iconUrl: './img/marker-icon-blue.png',\n    iconSize: [25, 41],\n    iconAnchor: [12,41]\n  });\n\n  const inactiveIcon = L.icon({\n    iconUrl: './img/marker-icon-gray.png',\n    iconSize: [25, 41],\n    iconAnchor: [12,41]\n  });\n\n  const boundariesLayer = L.geoJSON(boundaries, {\n    style: function (feature) {\n      return boundariesColor;\n    }\n  });\n\n  var clusters = L.markerClusterGroup({\n    spiderfyOnMaxZoom: true,\n    showCoverageOnHover: true,\n    zoomToBoundsOnClick: true,\n    chunkedLoading: true\n  });    \n\n\n\n  /** null markers block begin\n   * it's very important for first initialzation of the map\n  */\n  var ActivePeoples = L.geoJson(examplePersons, {\n    pointToLayer: function (feature, latlng) {\n      \n      var marker = L.marker(latlng, { \n        icon: (feature.properties.username?activeIcon:inactiveIcon)\n      });\n\n      //for making right position to fit all markers to the map\n      group.push(marker);    \n    }\n\n  });\n  \n    clusters.addLayer(boundariesLayer);\n    clusters.addLayer(ActivePeoples);\n\n  useEffect(() => {    \n    mapRef.current.addLayer(clusters)           \n\n  }, [clusters])\n  /** null markers block end*/\n  \n\n\n\n/**\n * this is callback from SearchControlList component\n * @param list  returns the list of tokens to updating of our markers\n * @return new person.json object \n */\n\nfunction updateInfo(data){\n\n  //console.log('updateInfo')\n  //console.log(data)\n  \n  clusters.removeLayer(ActivePeoples);        \n    \n  ActivePeoples = L.geoJson(data, {\n    pointToLayer: function (feature, latlng) { \n\n      \n      var marker = L.marker(latlng, { \n          icon: (feature.properties.username?activeIcon:inactiveIcon)\n        });\n\n      marker.bindPopup(\n        '<div class=\"popups-widget-top\">'+\n          '<img src=\"./img/programmer.png\" alt=\"avatar\"/>'+\n            '<div class=\"popups-top-right-section\">'+            \n            '<p>' + (feature.properties.username?'<a href=\"https://t.me/'+feature.properties.username+'\">@'+feature.properties.username+'  </a>':'<i>hidden </i>')\n                +'('+feature.properties.name + ')'+\n            '</p>'+\n            '<p class=\"city-name\"> from <b>'+feature.properties.city+'</b></p>' +       \n            '</div>'+\n         '</div>'+\n         '<div class=\"popups-widget-bottom\">'+\n            '<b>About:</b> ' + feature.properties.about +\n         '</div>'+\n         (feature.properties.username\n            ?''\n              :'<div class=\"popups-widget-bottom-error\">'+\n                  '<i class=\"error-info\">He/She needs to indicate a username</i></br>'+\n                  '<i class=\"error-info\">for communication</i>'+\n                  '</div>'\n         )\n      );\n\n\n      //marker.openPopup() doesnt work in Safari\n      //this is some hook             \n      function func() {\n        marker.openPopup();\n      }        \n      \n      //for making right position to fit all markers to the map\n      group.push(marker);\n\n      var utils = new Utils();\n      utils.Subscribe('click', marker, func);        \n      return marker;\n\n    }\n\n  });\n\n  clusters.addLayer(ActivePeoples);\n\n\n  /**\n     * if we have 1 person to view \n     * we fly to this person and see the map with maxZoom\n     */\n\n     \n  if( data.features && data.features.length == 1){\n    //console.log(data.features)\n    //console.log(data.features[0].geometry.coordinates)\n    \n    mapRef.current.flyTo([\n      data.features[0].geometry.coordinates[1],\n      data.features[0].geometry.coordinates[0]], \n      maxZoom)\n  }\n  if(data.features && data.features.length > 1 && group!=null && mapRef.current!=null){\n\n    //we fly to all clusters and set zoom to fit    \n    var markersGroup = new L.featureGroup(group);\n    mapRef.current.fitBounds(markersGroup.getBounds())\n  }\n}\n\n//props callback\n function closeSearch(event){\n   if(event == 'closed'){    \n      console.log('search bar was closed')\n      onLoading();    \n   }\n }\n\n\n //start script\n onLoading();\n\nreturn <div>\n          <SearchControl updateInfo={updateInfo} closeSearch={closeSearch}/>\n          <div id='map'></div>\n        </div>\n\n}","import React, { Component } from 'react';\nimport \"./App.css\";\nimport ContactMap from '../ContactMap/Contactmap';\n\n \nclass App extends Component {\n  \n  render() {\n    return (\n      <div>\n        <ContactMap/>\n      </div>\n    );\n  }\n}\n \nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App/App';\n\nReactDOM.render(\n    <App />,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}